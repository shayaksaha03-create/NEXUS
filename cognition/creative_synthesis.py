"""
NEXUS AI - Creative Synthesis Engine
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Enables NEXUS to be genuinely creative:
- Blend two concepts into something novel
- Brainstorm divergent ideas
- Generate innovative solutions to problems
- Evaluate novelty and originality
- Conceptual combination and recombination

Creativity is the hallmark of general intelligence â€” the ability
to produce ideas that are both novel AND useful.
"""

import threading
import json
import uuid
import time
import re
from datetime import datetime
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, field
from pathlib import Path
from enum import Enum

import sys
sys.path.insert(0, str(Path(__file__).resolve().parent.parent))

from config import DATA_DIR, NEXUS_CONFIG
from utils.logger import get_logger, log_learning
from core.event_bus import EventType, publish, subscribe, Event
from core.state_manager import state_manager

logger = get_logger("creative_synthesis")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DATA TYPES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class CreativityMode(Enum):
    """The mode of creative thinking"""
    DIVERGENT = "divergent"        # Generate many different ideas
    CONVERGENT = "convergent"      # Find the best solution
    LATERAL = "lateral"            # Think sideways / reframe  
    COMBINATORIAL = "combinatorial"  # Combine existing elements
    TRANSFORMATIVE = "transformative"  # Fundamentally change perspective


@dataclass
class CreativeIdea:
    """A creative idea generated by the engine"""
    idea_id: str = ""
    description: str = ""
    source_concepts: List[str] = field(default_factory=list)
    creativity_mode: CreativityMode = CreativityMode.DIVERGENT
    novelty_score: float = 0.5
    usefulness_score: float = 0.5
    surprise_factor: float = 0.5
    domain: str = ""
    connections: List[str] = field(default_factory=list)
    created_at: str = ""

    def to_dict(self) -> Dict:
        return {
            "idea_id": self.idea_id,
            "description": self.description,
            "source_concepts": self.source_concepts,
            "creativity_mode": self.creativity_mode.value,
            "novelty_score": self.novelty_score,
            "usefulness_score": self.usefulness_score,
            "surprise_factor": self.surprise_factor,
            "domain": self.domain,
            "connections": self.connections,
            "created_at": self.created_at,
        }

    @classmethod
    def from_dict(cls, data: Dict) -> "CreativeIdea":
        mode = CreativityMode.DIVERGENT
        try:
            mode = CreativityMode(data.get("creativity_mode", "divergent"))
        except ValueError:
            pass
        return cls(
            idea_id=data.get("idea_id", ""),
            description=data.get("description", ""),
            source_concepts=data.get("source_concepts", []),
            creativity_mode=mode,
            novelty_score=data.get("novelty_score", 0.5),
            usefulness_score=data.get("usefulness_score", 0.5),
            surprise_factor=data.get("surprise_factor", 0.5),
            domain=data.get("domain", ""),
            connections=data.get("connections", []),
            created_at=data.get("created_at", ""),
        )

    @property
    def creativity_score(self) -> float:
        """Combined score: novelty Ã— usefulness Ã— surprise"""
        return (self.novelty_score * 0.4 + self.usefulness_score * 0.3 + self.surprise_factor * 0.3)


@dataclass
class ConceptBlend:
    """A blend of two or more concepts into something new"""
    blend_id: str = ""
    input_concepts: List[str] = field(default_factory=list)
    blended_concept: str = ""
    explanation: str = ""
    emergent_properties: List[str] = field(default_factory=list)
    novelty_score: float = 0.5
    created_at: str = ""

    def to_dict(self) -> Dict:
        return {
            "blend_id": self.blend_id,
            "input_concepts": self.input_concepts,
            "blended_concept": self.blended_concept,
            "explanation": self.explanation,
            "emergent_properties": self.emergent_properties,
            "novelty_score": self.novelty_score,
            "created_at": self.created_at,
        }


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CREATIVE SYNTHESIS ENGINE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class CreativeSynthesisEngine:
    """
    Creative Synthesis Engine â€” Novel Idea Generation
    
    Capabilities:
    - blend(): Merge two concepts into something new
    - brainstorm(): Generate diverse ideas on a topic
    - innovate(): Find creative solutions to problems
    - reframe(): See a problem from a completely different angle
    - evaluate_novelty(): Score how original an idea is
    - free_associate(): Chain of consciousness creative exploration
    """
    
    _instance = None
    _lock = threading.Lock()

    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
                    cls._instance._initialized = False
        return cls._instance

    def __init__(self):
        if self._initialized:
            return
        self._initialized = True

        # â”€â”€â”€â”€ State â”€â”€â”€â”€
        self._ideas: Dict[str, CreativeIdea] = {}
        self._blends: Dict[str, ConceptBlend] = {}
        self._running = False
        self._data_lock = threading.Lock()

        # â”€â”€â”€â”€ LLM (lazy) â”€â”€â”€â”€
        self._llm = None

        # â”€â”€â”€â”€ Stats â”€â”€â”€â”€
        self._total_ideas = 0
        self._total_blends = 0
        self._total_innovations = 0

        # â”€â”€â”€â”€ Persistence â”€â”€â”€â”€
        self._data_dir = DATA_DIR / "cognition"
        self._data_dir.mkdir(parents=True, exist_ok=True)
        self._data_file = self._data_dir / "creative_ideas.json"

        self._load_data()
        logger.info(f"CreativeSynthesisEngine initialized â€” {len(self._ideas)} ideas stored")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # LIFECYCLE
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def start(self):
        if self._running:
            return
        self._running = True
        self._load_llm()
        logger.info("ğŸ¨ Creative Synthesis Engine started")

    def stop(self):
        self._running = False
        self._save_data()
        logger.info("Creative Synthesis Engine stopped")

    def _load_llm(self):
        if self._llm is None:
            try:
                from llm.llama_interface import llm
                self._llm = llm
            except ImportError:
                logger.warning("LLM not available for creative synthesis")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # CORE OPERATIONS
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def blend(self, concept_a: str, concept_b: str) -> Optional[ConceptBlend]:
        """
        Blend two concepts into something genuinely new.
        
        Example:
          blend("restaurant", "library")
          â†’ "A silent dining experience where meals are paired with books,
             and the menu changes based on what's being read in the room"
        """
        self._load_llm()
        if not self._llm or not self._llm.is_connected:
            return self._fallback_blend(concept_a, concept_b)

        try:
            prompt = (
                f'CONCEPTUAL BLENDING CHALLENGE:\n'
                f'Concept A: "{concept_a}"\n'
                f'Concept B: "{concept_b}"\n\n'
                f"Create something GENUINELY NEW by blending these two concepts. "
                f"Don't just combine them superficially â€” find the deep structural "
                f"intersection and build something that has EMERGENT properties "
                f"(properties that neither A nor B have alone).\n\n"
                f"Respond ONLY with JSON:\n"
                f'{{"blended_concept": "name of the new thing", '
                f'"explanation": "how the blend works", '
                f'"emergent_properties": ["new property 1", "new property 2"], '
                f'"novelty_score": 0.0-1.0}}'
            )

            response = self._llm.generate(
                prompt=prompt,
                system_prompt="You are a radical creativity engine. Generate truly novel ideas by blending concepts in unexpected ways. Respond ONLY with valid JSON.",
                temperature=0.9,
                max_tokens=500
            )

            if response.success:
                data = self._parse_json(response.text)
                if data:
                    blend = ConceptBlend(
                        blend_id=str(uuid.uuid4())[:12],
                        input_concepts=[concept_a, concept_b],
                        blended_concept=data.get("blended_concept", ""),
                        explanation=data.get("explanation", ""),
                        emergent_properties=data.get("emergent_properties", []),
                        novelty_score=float(data.get("novelty_score", 0.6)),
                        created_at=datetime.now().isoformat(),
                    )
                    with self._data_lock:
                        self._blends[blend.blend_id] = blend
                        self._total_blends += 1
                    self._save_data()
                    log_learning(f"Created blend: {concept_a} + {concept_b} = {blend.blended_concept}")
                    return blend

        except Exception as e:
            logger.error(f"Concept blending failed: {e}")

        return self._fallback_blend(concept_a, concept_b)

    def brainstorm(self, topic: str, count: int = 5, mode: CreativityMode = CreativityMode.DIVERGENT) -> List[CreativeIdea]:
        """
        Generate multiple creative ideas on a topic.
        Uses the specified creativity mode to shape the type of ideas.
        """
        self._load_llm()
        if not self._llm or not self._llm.is_connected:
            return []

        mode_instructions = {
            CreativityMode.DIVERGENT: "Generate wildly different ideas, as far apart as possible",
            CreativityMode.CONVERGENT: "Generate ideas that converge on the best possible solution",
            CreativityMode.LATERAL: "Think sideways â€” reframe the problem itself before solving it",
            CreativityMode.COMBINATORIAL: "Combine unexpected elements from different fields",
            CreativityMode.TRANSFORMATIVE: "Challenge fundamental assumptions and create paradigm shifts",
        }

        try:
            prompt = (
                f'BRAINSTORM: Generate {count} creative ideas about "{topic}".\n\n'
                f"Mode: {mode.value.upper()}\n"
                f"Instruction: {mode_instructions.get(mode, 'Be creative')}\n\n"
                f"Make each idea SURPRISING and USEFUL. Avoid obvious or clichÃ© ideas.\n\n"
                f"Respond ONLY with a JSON array:\n"
                f'[{{"description": "the idea", "novelty_score": 0.0-1.0, '
                f'"usefulness_score": 0.0-1.0, "surprise_factor": 0.0-1.0, '
                f'"domain": "relevant field", "connections": ["related concept"]}}]'
            )

            response = self._llm.generate(
                prompt=prompt,
                system_prompt="You are a divergent thinking engine. Generate surprising, non-obvious ideas. Respond ONLY with valid JSON array.",
                temperature=0.9,
                max_tokens=800
            )

            if response.success:
                text = response.text.strip()
                match = re.search(r'\[.*\]', text, re.DOTALL)
                if match:
                    items = json.loads(match.group())
                    ideas = []
                    for item in items[:count]:
                        idea = CreativeIdea(
                            idea_id=str(uuid.uuid4())[:12],
                            description=item.get("description", ""),
                            source_concepts=[topic],
                            creativity_mode=mode,
                            novelty_score=float(item.get("novelty_score", 0.5)),
                            usefulness_score=float(item.get("usefulness_score", 0.5)),
                            surprise_factor=float(item.get("surprise_factor", 0.5)),
                            domain=item.get("domain", ""),
                            connections=item.get("connections", []),
                            created_at=datetime.now().isoformat(),
                        )
                        ideas.append(idea)
                        with self._data_lock:
                            self._ideas[idea.idea_id] = idea
                            self._total_ideas += 1
                    self._save_data()
                    return ideas

        except Exception as e:
            logger.error(f"Brainstorming failed: {e}")

        return []

    def innovate(self, problem: str, constraints: List[str] = None) -> List[CreativeIdea]:
        """
        Generate innovative solutions to a specific problem.
        Optionally considers constraints.
        """
        self._load_llm()
        if not self._llm or not self._llm.is_connected:
            return []

        try:
            constraints_str = ""
            if constraints:
                constraints_str = "\nConstraints:\n" + "\n".join(f"  - {c}" for c in constraints)

            prompt = (
                f'INNOVATION CHALLENGE:\n'
                f'Problem: "{problem}"{constraints_str}\n\n'
                f"Generate 3 innovative solutions that:\n"
                f"1. Challenge conventional approaches\n"
                f"2. Could actually work in practice\n"
                f"3. Have something genuinely novel about them\n\n"
                f"Respond ONLY with a JSON array:\n"
                f'[{{"description": "the solution", "novelty_score": 0.0-1.0, '
                f'"usefulness_score": 0.0-1.0, "surprise_factor": 0.0-1.0, '
                f'"how_it_works": "brief explanation"}}]'
            )

            response = self._llm.generate(
                prompt=prompt,
                system_prompt="You are an innovation engine. Find non-obvious solutions to problems. Respond ONLY with valid JSON array.",
                temperature=0.8,
                max_tokens=700
            )

            if response.success:
                text = response.text.strip()
                match = re.search(r'\[.*\]', text, re.DOTALL)
                if match:
                    items = json.loads(match.group())
                    ideas = []
                    for item in items:
                        idea = CreativeIdea(
                            idea_id=str(uuid.uuid4())[:12],
                            description=item.get("description", ""),
                            source_concepts=[problem],
                            creativity_mode=CreativityMode.CONVERGENT,
                            novelty_score=float(item.get("novelty_score", 0.6)),
                            usefulness_score=float(item.get("usefulness_score", 0.7)),
                            surprise_factor=float(item.get("surprise_factor", 0.5)),
                            domain="innovation",
                            connections=[item.get("how_it_works", "")],
                            created_at=datetime.now().isoformat(),
                        )
                        ideas.append(idea)
                        with self._data_lock:
                            self._ideas[idea.idea_id] = idea
                            self._total_innovations += 1
                    self._save_data()
                    return ideas

        except Exception as e:
            logger.error(f"Innovation failed: {e}")

        return []

    def reframe(self, problem: str) -> List[str]:
        """
        Reframe a problem by looking at it from completely different angles.
        Returns a list of alternative framings.
        """
        self._load_llm()
        if not self._llm or not self._llm.is_connected:
            return [f"Alternative view of: {problem}"]

        try:
            prompt = (
                f'REFRAMING: Look at this problem from 4 completely different perspectives:\n'
                f'"{problem}"\n\n'
                f"Each reframe should change the fundamental nature of the question.\n"
                f"Example: 'How to lose weight' â†’ 'How to develop a loving relationship with food'\n\n"
                f"Respond ONLY with a JSON array of strings:\n"
                f'["reframe 1", "reframe 2", "reframe 3", "reframe 4"]'
            )

            response = self._llm.generate(
                prompt=prompt,
                system_prompt="You are a lateral thinking engine. Reframe problems in surprising ways. Respond ONLY with valid JSON array of strings.",
                temperature=0.85,
                max_tokens=400
            )

            if response.success:
                text = response.text.strip()
                match = re.search(r'\[.*\]', text, re.DOTALL)
                if match:
                    frames = json.loads(match.group())
                    if isinstance(frames, list):
                        return [str(f) for f in frames]

        except Exception as e:
            logger.error(f"Reframing failed: {e}")

        return [f"Alternative view of: {problem}"]

    def evaluate_novelty(self, idea: str) -> Dict[str, Any]:
        """Score how novel/original an idea is"""
        self._load_llm()
        if not self._llm or not self._llm.is_connected:
            return {"novelty": 0.5, "evaluation": "LLM unavailable"}

        try:
            prompt = (
                f'Rate the NOVELTY of this idea:\n"{idea}"\n\n'
                f"Score on these dimensions:\n"
                f"- Originality: How unlike existing ideas is this? (0-1)\n"
                f"- Surprise: How unexpected is it? (0-1)\n"
                f"- Usefulness: How practical/valuable is it? (0-1)\n"
                f"- Elegance: How simple yet powerful is it? (0-1)\n\n"
                f"Respond ONLY with JSON:\n"
                f'{{"originality": 0.0-1.0, "surprise": 0.0-1.0, "usefulness": 0.0-1.0, '
                f'"elegance": 0.0-1.0, "overall": 0.0-1.0, "verdict": "one sentence"}}'
            )

            response = self._llm.generate(
                prompt=prompt,
                system_prompt="You are a creativity evaluator. Score novelty rigorously. Respond ONLY with valid JSON.",
                temperature=0.3,
                max_tokens=300
            )

            if response.success:
                data = self._parse_json(response.text)
                if data:
                    return data

        except Exception as e:
            logger.error(f"Novelty evaluation failed: {e}")

        return {"novelty": 0.5, "evaluation": "Assessment unavailable"}

    def free_associate(self, seed: str, steps: int = 5) -> List[str]:
        """
        Chain of consciousness â€” start from a seed concept and free-associate
        through unexpected connections.
        """
        self._load_llm()
        if not self._llm or not self._llm.is_connected:
            return [seed]

        try:
            prompt = (
                f'FREE ASSOCIATION CHAIN: Starting from "{seed}", '
                f"follow {steps} unexpected associative leaps.\n\n"
                f"Each step should be a SURPRISING connection to the previous, "
                f"not an obvious one. Think like a jazz musician â€” riff and jump.\n\n"
                f"Respond ONLY with a JSON array:\n"
                f'["{seed}", "surprising connection 1", "leap 2", ...]'
            )

            response = self._llm.generate(
                prompt=prompt,
                system_prompt="You are a free-association engine. Make surprising, non-obvious conceptual leaps. Respond ONLY with valid JSON array.",
                temperature=0.95,
                max_tokens=300
            )

            if response.success:
                text = response.text.strip()
                match = re.search(r'\[.*\]', text, re.DOTALL)
                if match:
                    chain = json.loads(match.group())
                    if isinstance(chain, list):
                        return [str(c) for c in chain[:steps + 1]]

        except Exception as e:
            logger.error(f"Free association failed: {e}")

        return [seed]

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # RETRIEVAL
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def get_ideas(self, limit: int = 20) -> List[CreativeIdea]:
        with self._data_lock:
            items = sorted(self._ideas.values(), key=lambda i: i.created_at, reverse=True)
            return items[:limit]

    def get_best_ideas(self, limit: int = 10) -> List[CreativeIdea]:
        """Get top ideas by creativity score"""
        with self._data_lock:
            items = sorted(self._ideas.values(), key=lambda i: i.creativity_score, reverse=True)
            return items[:limit]

    def get_blends(self, limit: int = 20) -> List[ConceptBlend]:
        with self._data_lock:
            items = sorted(self._blends.values(), key=lambda b: b.created_at, reverse=True)
            return items[:limit]

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # HELPERS
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _parse_json(self, text: str) -> Optional[Dict]:
        try:
            return json.loads(text.strip())
        except json.JSONDecodeError:
            match = re.search(r'\{.*\}', text, re.DOTALL)
            if match:
                try:
                    return json.loads(match.group())
                except json.JSONDecodeError:
                    pass
        return None

    def _fallback_blend(self, a: str, b: str) -> ConceptBlend:
        return ConceptBlend(
            blend_id=str(uuid.uuid4())[:12],
            input_concepts=[a, b],
            blended_concept=f"{a}-{b} Hybrid",
            explanation=f"A combination of {a} and {b}",
            novelty_score=0.3,
            created_at=datetime.now().isoformat(),
        )

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # PERSISTENCE
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _save_data(self):
        try:
            data = {
                "ideas": {k: v.to_dict() for k, v in self._ideas.items()},
                "blends": {k: v.to_dict() for k, v in self._blends.items()},
                "stats": {
                    "total_ideas": self._total_ideas,
                    "total_blends": self._total_blends,
                    "total_innovations": self._total_innovations,
                },
            }
            with open(self._data_file, "w") as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            logger.error(f"Failed to save creative data: {e}")

    def _load_data(self):
        try:
            if self._data_file.exists():
                with open(self._data_file) as f:
                    data = json.load(f)
                for k, v in data.get("ideas", {}).items():
                    self._ideas[k] = CreativeIdea.from_dict(v)
                for k, v in data.get("blends", {}).items():
                    b = ConceptBlend(
                        blend_id=v.get("blend_id", k),
                        input_concepts=v.get("input_concepts", []),
                        blended_concept=v.get("blended_concept", ""),
                        explanation=v.get("explanation", ""),
                        emergent_properties=v.get("emergent_properties", []),
                        novelty_score=v.get("novelty_score", 0.5),
                        created_at=v.get("created_at", ""),
                    )
                    self._blends[k] = b
                stats = data.get("stats", {})
                self._total_ideas = stats.get("total_ideas", 0)
                self._total_blends = stats.get("total_blends", 0)
                self._total_innovations = stats.get("total_innovations", 0)
        except Exception as e:
            logger.warning(f"Failed to load creative data: {e}")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # STATS
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        def scamper(self, concept: str) -> Dict[str, Any]:
            """Apply SCAMPER creative thinking to generate novel ideas."""
            self._load_llm()
            if not self._llm or not self._llm.is_connected:
                return {"error": "LLM not available"}
            try:
                prompt = (
                    f'Apply the SCAMPER creative framework to:\n'
                    f'"{concept}"\n\n'
                    f"Generate ideas for each SCAMPER dimension:\n"
                    f"  S - SUBSTITUTE: What can be replaced?\n"
                    f"  C - COMBINE: What can be merged with something else?\n"
                    f"  A - ADAPT: How can it be adjusted for a different use?\n"
                    f"  M - MODIFY: What can be magnified, minimized, or changed?\n"
                    f"  P - PUT TO OTHER USE: What else could this be used for?\n"
                    f"  E - ELIMINATE: What can be removed to simplify?\n"
                    f"  R - REVERSE: What if we flip the approach?\n\n"
                    f"Respond ONLY with JSON:\n"
                    f'{{"substitute": [{{"idea": "what to substitute", "benefit": "why"}}], '
                    f'"combine": [{{"idea": "what to combine", "benefit": "why"}}], '
                    f'"adapt": [{{"idea": "how to adapt", "benefit": "why"}}], '
                    f'"modify": [{{"idea": "what to modify", "benefit": "why"}}], '
                    f'"put_to_other_use": [{{"idea": "alternative use", "benefit": "why"}}], '
                    f'"eliminate": [{{"idea": "what to remove", "benefit": "why"}}], '
                    f'"reverse": [{{"idea": "what to flip", "benefit": "why"}}], '
                    f'"best_ideas": ["top 3 most promising ideas"]}}'
                )
                response = self._llm.generate(
                    prompt=prompt,
                    system_prompt=(
                        "You are a creative thinking engine using the SCAMPER method -- one of the most "
                        "powerful systematic creativity techniques. Generate genuinely novel and useful ideas. "
                        "Respond ONLY with valid JSON."
                    ),
                    temperature=0.8, max_tokens=1000
                )
                if response.success:
                    return self._parse_json(response.text) or {"error": "Parse failed"}
            except Exception as e:
                logger.error(f"SCAMPER failed: {e}")
            return {"error": "SCAMPER failed"}


    def get_stats(self) -> Dict[str, Any]:
            return {
                "running": self._running,
                "total_ideas_stored": len(self._ideas),
                "total_blends_stored": len(self._blends),
                "total_ideas_generated": self._total_ideas,
                "total_blends_performed": self._total_blends,
                "total_innovations": self._total_innovations,
            }


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SINGLETON
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

creative_synthesis = CreativeSynthesisEngine()

def get_creative_synthesis() -> CreativeSynthesisEngine:
    return creative_synthesis